# i960 / 80960


define endian=little;

define alignment=4;

define space ram type=ram_space size=4 default;

define space register type=register_space size=4;

@define SALIGN 1

define register offset=0 size=4 [ pfp sp rip r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 g10 g11 g12 g13 g14 fp ];

define register offset=0x100 size=4 [ sf0 sf1 sf2 sf3 sf4 sf5 sf6 sf7 sf8 sf9 sf10 sf11 sf12 sf13 sf14 sf15 sf16 sf17 sf18 sf19 sf20 sf21 sf22 sf23 sf24 sf25 sf26 sf27 sf28 sf29 sf30 sf31 ];


define register offset=0 size=8 [ rl_pfp_sp rl_rip_r3 rl_r4_r5 rl_r6_r7 rl_r8_r9 rl_r10_r11 rl_r12_r13 rl_r14_r15 rl_g0_g1 rl_g2_g3 rl_g4_g5 rl_g6_g7 rl_g8_g9 rl_g10_g11 rl_g12_g13 rl_g14_fp ];

define register offset=0x100 size=8 [ sfrl_sf0_sf1 sfrl_sf2_sf3 sfrl_sf4_sf5 sfrl_sf6_sf7 sfrl_sf8_sf9 sfrl_sf10_sf11 sfrl_sf12_sf13 sfrl_sf14_sf15 sfrl_sf16_sf17 sfrl_sf18_sf19 sfrl_sf20_sf21 sfrl_sf22_sf23 sfrl_sf24_sf25 sfrl_sf26_sf27 sfrl_sf28_sf29 sfrl_sf30_sf31 ];


#ATTN  Must be multiple of 4, results are unpredictable otherwise
define register offset=0x0 size=12 [ rt_pfp_sp_rip ];
define register offset=0x10 size=12 [ rt_r4_r5_r6 ];
define register offset=0x20 size=12 [ rt_r8_r9_r10 ];
define register offset=0x30 size=12 [ rt_r12_r13_r14 ];
define register offset=0x40 size=12 [ rt_g0_g1_g2 ];
define register offset=0x50 size=12 [ rt_g4_g5_g6 ];
define register offset=0x60 size=12 [ rt_g8_g9_g10 ];
define register offset=0x70 size=12 [ rt_g12_g13_g14 ];

define register offset=0x100 size=12 [ sfrt_sf0_sf1_sf2 ];
define register offset=0x110 size=12 [ sfrt_sf4_sf5_sf6 ];
define register offset=0x120 size=12 [ sfrt_sf8_sf9_sf10 ];
define register offset=0x130 size=12 [ sfrt_sf12_sf13_sf14 ];
define register offset=0x140 size=12 [ sfrt_sf16_sf17_sf18 ];
define register offset=0x150 size=12 [ sfrt_sf20_sf21_sf22 ];
define register offset=0x160 size=12 [ sfrt_sf24_sf25_sf26 ];
define register offset=0x170 size=12 [ sfrt_sf28_sf29_sf30 ];


define register offset=0x0 size=16 [ rq_pfp_sp_rip_r3 rq_r4_r5_r6_r7 rq_r8_r9_r10_r11 rq_r12_r13_r14_r15 rq_g0_g1_g2_g3 rq_g4_g5_g6_g7 rq_g8_g9_g10_g11 rq_g12_g13_g14_fp ];

define register offset=0x100 size=16 [ sfrq_sf0_sf1_sf2_sf3 sfrq_sf4_sf5_sf6_sf7 sfrq_sf8_sf9_sf10_sf11 sfrq_sf12_sf13_sf14_sf15 sfrq_sf16_sf17_sf18_sf19 sfrq_sf20_sf21_sf22_sf23 sfrq_sf24_sf25_sf26_sf27 sfrq_sf28_sf29_sf30_sf31 ];

define register offset=0x200 size=4 [ pc ac ip tc ];


# 80-bit registers  extended-real format
define register offset=0x300 size=10 [ fp0 fp1 fp2 fp3 ];



define token instr (32)
  op2431=(24,31)
  freg1923=(19,23)
  reg1923=(19,23)
  reg1923l=(19,23)
  reg1923t=(19,23)
  reg1923q=(19,23)
  sfr1923=(19,23)
  sfr1923l=(19,23)
  sfr1923t=(19,23)
  sfr1923q=(19,23)
  fp1923=(19,23)
  op1923=(19,23)
  freg1418=(14,18)
  reg1418=(14,18)
  reg1418l=(14,18)
  reg1418t=(14,18)
  reg1418q=(14,18)
  sfr1418=(14,18)
  sfr1418l=(14,18)
  sfr1418t=(14,18)
  sfr1418q=(14,18)
  fp1418=(14,18)
  op1418=(14,18)
  m2=(13,13)
  m1=(12,12)
  m0=(11,11)
  op0710=(7,10)
  s1=(6,6)
  s0=(5,5)
  freg0004=(0,4)
  reg0004=(0,4)
  reg0004l=(0,4)
  reg0004t=(0,4)
  reg0004q=(0,4)
  sfr0004=(0,4)
  sfr0004l=(0,4)
  sfr0004t=(0,4)
  sfr0004q=(0,4)
  fp0004=(0,4)
  op0004=(0,4)
  sdisp0212=(2,12) signed
  t=(1,1)
  s2=(0,0)
  sdisp0223=(2,23) signed
  op0000=(0,0)
  mode1213=(12,13)
  mode1011=(10,11)
  offset0011=(0,11)
  scale=(7,9)
  op0506=(5,6)
;


define token instr2 (32)
  sdisp0031=(0,31) signed
;



attach variables [ reg0004 reg1418 reg1923 ]
                 [ pfp sp rip r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 g10 g11 g12 g13 g14 fp ];

attach variables [ reg0004l reg1418l reg1923l ]
                 [ rl_pfp_sp _ rl_rip_r3 _ rl_r4_r5 _ rl_r6_r7 _ rl_r8_r9 _ rl_r10_r11 _ rl_r12_r13 _ rl_r14_r15 _ rl_g0_g1 _ rl_g2_g3 _ rl_g4_g5 _ rl_g6_g7 _ rl_g8_g9 _ rl_g10_g11 _ rl_g12_g13 _ rl_g14_fp _ ];

attach variables [ reg0004t reg1418t reg1923t ]
                 [ rt_pfp_sp_rip _ _ _ rt_r4_r5_r6 _ _ _ rt_r8_r9_r10 _ _ _ rt_r12_r13_r14 _ _ _ rt_g0_g1_g2 _ _ _ rt_g4_g5_g6 _ _ _ rt_g8_g9_g10 _ _ _ rt_g12_g13_g14 _ _ _ ];

attach variables [ reg0004q reg1418q reg1923q ]
                 [ rq_pfp_sp_rip_r3 _ _ _ rq_r4_r5_r6_r7 _ _ _ rq_r8_r9_r10_r11 _ _ _ rq_r12_r13_r14_r15 _ _ _ rq_g0_g1_g2_g3 _ _ _ rq_g4_g5_g6_g7 _ _ _ rq_g8_g9_g10_g11 _ _ _ rq_g12_g13_g14_fp _ _ _ ];

attach variables [ sfr0004 sfr1418 sfr1923 ]
                 [ sf0 sf1 sf2 sf3 sf4 sf5 sf6 sf7 sf8 sf9 sf10 sf11 sf12 sf13 sf14 sf15 sf16 sf17 sf18 sf19 sf20 sf21 sf22 sf23 sf24 sf25 sf26 sf27 sf28 sf29 sf30 sf31 ];

attach variables [ sfr0004l sfr1418l sfr1923l ]
                 [ sfrl_sf0_sf1 _ sfrl_sf2_sf3 _ sfrl_sf4_sf5 _ sfrl_sf6_sf7 _ sfrl_sf8_sf9 _ sfrl_sf10_sf11 _ sfrl_sf12_sf13 _ sfrl_sf14_sf15 _ sfrl_sf16_sf17 _ sfrl_sf18_sf19 _ sfrl_sf20_sf21 _ sfrl_sf22_sf23 _ sfrl_sf24_sf25 _ sfrl_sf26_sf27 _ sfrl_sf28_sf29 _ sfrl_sf30_sf31 _ ];

attach variables [ sfr0004t sfr1418t sfr1923t ]
                 [ sfrt_sf0_sf1_sf2 _ _ _ sfrt_sf4_sf5_sf6 _ _ _ sfrt_sf8_sf9_sf10 _ _ _ sfrt_sf12_sf13_sf14 _ _ _ sfrt_sf16_sf17_sf18 _ _ _ sfrt_sf20_sf21_sf22 _ _ _ sfrt_sf24_sf25_sf26 _ _ _ sfrt_sf28_sf29_sf30 _ _ _ ];

attach variables [ sfr0004q sfr1418q sfr1923q ]
                 [ sfrq_sf0_sf1_sf2_sf3 _ _ _ sfrq_sf4_sf5_sf6_sf7 _ _ _ sfrq_sf8_sf9_sf10_sf11 _ _ _ sfrq_sf12_sf13_sf14_sf15 _ _ _ sfrq_sf16_sf17_sf18_sf19 _ _ _ sfrq_sf20_sf21_sf22_sf23 _ _ _ sfrq_sf24_sf25_sf26_sf27 _ _ _ sfrq_sf28_sf29_sf30_sf31 _ _ _ ];

attach variables [ freg0004 freg1418 freg1923 ]
                 [ fp0 fp1 fp2 fp3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ];


#TODO CC    appears to be:  (mask & cc || mask == cc)
# 010 true
# 000 false
# 000 unordered
# 001 gt
# 010 eq
# 100 lt
# 01X carry out
# 0X1 overflow


regS1: reg0004 is reg0004 & m2 & m1 & m0=0 & s1 & s0=0 { local tmp:4 = reg0004; export tmp; }
regS1l: reg0004l is reg0004l & m2 & m1 & m0=0 & s1 & s0=0 { export reg0004l; }
regS1t: reg0004t is reg0004t & m2 & m1 & m0=0 & s1 & s0=0 { export reg0004t; }
regS1q: reg0004q is reg0004q & m2 & m1 & m0=0 & s1 & s0=0 { export reg0004q; }
regS1: op0004 is op0004 & m2 & m1 & m0=1 & s1 & s0=0 { local tmp:4 = op0004; export tmp; }
regS1l: op0004 is op0004 & m2 & m1 & m0=1 & s1 & s0=0 { local tmp:8 = op0004; export tmp; }
regS1t: op0004 is op0004 & m2 & m1 & m0=1 & s1 & s0=0 { local tmp:12 = op0004; export tmp; }
regS1q: op0004 is op0004 & m2 & m1 & m0=1 & s1 & s0=0 { local tmp:16 = op0004; export tmp; }
regS1: sfr0004 is sfr0004 & m2 & m1 & m0=0 & s1 & s0=1 { local tmp:4 = sfr0004; export tmp; }
regS1l: sfr0004l is sfr0004l & m2 & m1 & m0=0 & s1 & s0=1 { export sfr0004l; }
regS1t: sfr0004t is sfr0004t & m2 & m1 & m0=0 & s1 & s0=1 { export sfr0004t; }
regS1q: sfr0004q is sfr0004q & m2 & m1 & m0=0 & s1 & s0=1 { export sfr0004q; }
regS2: reg1418 is reg1418 & m2 & m1=0 & m0 & s1=0 & s0 { export reg1418; }
regS2l: reg1418l is reg1418l & m2 & m1=0 & m0 & s1=0 & s0 { export reg1418l; }
regS2t: reg1418t is reg1418t & m2 & m1=0 & m0 & s1=0 & s0 { export reg1418t; }
regS2q: reg1418q is reg1418q & m2 & m1=0 & m0 & s1=0 & s0 { export reg1418q; }
regS2: op1418 is op1418 & m2 & m1=1 & m0 & s1=0 & s0 { local tmp:4 = op1418; export tmp; }
regS2l: op1418 is op1418 & m2 & m1=1 & m0 & s1=0 & s0 { local tmp:8 = op1418; export tmp; }
regS2t: op1418 is op1418 & m2 & m1=1 & m0 & s1=0 & s0 { local tmp:12 = op1418; export tmp; }
regS2q: op1418 is op1418 & m2 & m1=1 & m0 & s1=0 & s0 { local tmp:16 = op1418; export tmp; }
regS2: sfr1418 is sfr1418 & m2 & m1=0 & m0 & s1=1 & s0 { export sfr1418; }
regS2l: sfr1418l is sfr1418l & m2 & m1=0 & m0 & s1=1 & s0 { export sfr1418l; }
regS2t: sfr1418t is sfr1418t & m2 & m1=0 & m0 & s1=1 & s0 { export sfr1418t; }
regS2q: sfr1418q is sfr1418q & m2 & m1=0 & m0 & s1=1 & s0 { export sfr1418q; }
regSD: reg1923 is reg1923 & m2=0 & m1 & m0 & s1 & s0 { export reg1923; }
regSDl: reg1923l is reg1923l & m2=0 & m1 & m0 & s1 & s0 { export reg1923l; }
regSDt: reg1923t is reg1923t & m2=0 & m1 & m0 & s1 & s0 { export reg1923t; }
regSDq: reg1923q is reg1923q & m2=0 & m1 & m0 & s1 & s0 { export reg1923q; }
cobrS1: reg0004 is reg0004 & m2=0 & s2=0 & t { export reg0004; }
cobrS1l: reg0004l is reg0004 & m2=0 & s2=0 & t { export reg0004l; }
cobrS1t: reg0004t is reg0004 & m2=0 & s2=0 & t { export reg0004t; }
cobrS1q: reg0004q is reg0004 & m2=0 & s2=0 & t { export reg0004q; }
cobrS2: reg1418 is reg1418 & m2=0 & s2=0 & t { export reg1418; }
cobrS2l: reg1418l is reg1418l & m2=0 & s2=0 & t { export reg1418l; }
cobrS2t: reg1418t is reg1418t & m2=0 & s2=0 & t { export reg1418t; }
cobrS2q: reg1418q is reg1418q & m2=0 & s2=0 & t { export reg1418q; }
cobrSD:  reg1923 is reg1923 & m2=0 & s2=0 & t { export reg1923; }
cobrSDl:  reg1923l is reg1923l & m2=0 & s2=0 & t { export reg1923l; }
cobrSDt:  reg1923t is reg1923t & m2=0 & s2=0 & t { export reg1923t; }
cobrSDq:  reg1923q is reg1923q & m2=0 & s2=0 & t { export reg1923q; }
cobrS1: op0004 is op0004 & m2=1 & s2=0 & t { export op0004; }
cobrS2: reg1418 is reg1418 & m2=1 & s2=0 & t { export reg1418; }
cobrS2l: reg1418l is reg1418l & m2=1 & s2=0 & t { export reg1418l; }
cobrS2t: reg1418t is reg1418t & m2=1 & s2=0 & t { export reg1418t; }
cobrS2q: reg1418q is reg1418q & m2=1 & s2=0 & t { export reg1418q; }
cobrSD:  reg1923 is reg1923 & m2=1 & s2=0 & t { export reg1923; }
cobrSDl:  reg1923l is reg1923l & m2=1 & s2=0 & t { export reg1923l; }
cobrSDt:  reg1923t is reg1923t & m2=1 & s2=0 & t { export reg1923t; }
cobrSDq:  reg1923q is reg1923q & m2=1 & s2=0 & t { export reg1923q; }
cobrS1: reg0004 is reg0004 & m2=0 & s2=1 & t { export reg0004; }
cobrS1l: reg0004l is reg0004l & m2=0 & s2=1 & t { export reg0004l; }
cobrS1t: reg0004t is reg0004t & m2=0 & s2=1 & t { export reg0004t; }
cobrS1q: reg0004q is reg0004q & m2=0 & s2=1 & t { export reg0004q; }
cobrS2: sfr1418 is sfr1418 & m2=0 & s2=1 & t { export sfr1418; }
cobrS2l: sfr1418l is sfr1418l & m2=0 & s2=1 & t { export sfr1418l; }
cobrS2t: sfr1418t is sfr1418t & m2=0 & s2=1 & t { export sfr1418t; }
cobrS2q: sfr1418q is sfr1418q & m2=0 & s2=1 & t { export sfr1418q; }
cobrSD:  sfr1923 is sfr1923 & m2=0 & s2=1 & t { export sfr1923; }
cobrSDl:  sfr1923l is sfr1923l & m2=0 & s2=1 & t { export sfr1923l; }
cobrSDt:  sfr1923t is sfr1923t & m2=0 & s2=1 & t { export sfr1923t; }
cobrSDq:  sfr1923q is sfr1923q & m2=0 & s2=1 & t { export sfr1923q; }
cobrS1: op0004 is op0004 & m2=1 & s2=0 & t=0 { export op0004; }
cobrS2: sfr1418 is sfr1418 & m2=1 & s2=1 & t=0 { export sfr1418; }
cobrS2l: sfr1418l is sfr1418l & m2=1 & s2=1 & t=0 { export sfr1418l; }
cobrS2t: sfr1418t is sfr1418t & m2=1 & s2=1 & t=0 { export sfr1418t; }
cobrS2q: sfr1418q is sfr1418q & m2=1 & s2=1 & t=0 { export sfr1418q; }
cobrSD:  sfr1923 is sfr1923 & m2=1 & s2=1 & t=0 { export sfr1923; }
cobrSDl:  sfr1923l is sfr1923l & m2=1 & s2=1 & t=0 { export sfr1923l; }
cobrSDt:  sfr1923t is sfr1923t & m2=1 & s2=1 & t=0 { export sfr1923t; }
cobrSDq:  sfr1923q is sfr1923q & m2=1 & s2=1 & t=0 { export sfr1923q; }

#TODO  floating-point needs work
#TODO  these must export the same size, so not sure how to handle
#      that with the automatic conversion this chip does.  that might
#      mean alot of duplicate instructions with m0=1|0 or can the int2float
#      go right here and that will make sense... think so???
# fregS1: reg0004 is reg0004 & m2 & m1 & m0=0 & s1 & s0=0 { export reg0004; }
# fregS1: freg0004 is freg0004 & m2 & m1 & m0=1 & s1 & s0=0 & op0004 < 4 { export freg0004;}
# fregS1: 0.0 is freg0004 & m2 & m1 & m0=1 & s1 & s0=0 & op0004 = 0x10 { local tmp = 0.0; export tmp; }
# fregS1: 1.0 is freg0004 & m2 & m1 & m0=1 & s1 & s0=0 & op0004 = 0x1f { local tmp = 1.0; export tmp; }




efa1: offset0011 is offset0011 & mode1213=0 { export *[ram]:1 offset0011; }
efa1: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:1 tmp; }
efa1: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:1 tmp; }
efa1: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:1 tmp; }
efa1: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:1 tmp; }
efa1: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:1 tmp; }
efa1: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:1 tmp; }
efa1: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:1 tmp; }
efa1: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:1 tmp; }


efa12: offset0011 is offset0011 & mode1213=0 { export *[ram]:12 offset0011; }
efa12: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:12 tmp; }
efa12: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:12 tmp; }
efa12: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:12 tmp; }
efa12: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:12 tmp; }
efa12: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:12 tmp; }
efa12: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:12 tmp; }
efa12: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:12 tmp; }
efa12: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:12 tmp; }


efa16: offset0011 is offset0011 & mode1213=0 { export *[ram]:16 offset0011; }
efa16: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:16 tmp; }
efa16: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:16 tmp; }
efa16: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:16 tmp; }
efa16: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:16 tmp; }
efa16: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:16 tmp; }
efa16: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:16 tmp; }
efa16: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:16 tmp; }
efa16: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:16 tmp; }


efa2: offset0011 is offset0011 & mode1213=0 { export *[ram]:2 offset0011; }
efa2: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:2 tmp; }
efa2: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:2 tmp; }
efa2: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:2 tmp; }
efa2: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:2 tmp; }
efa2: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:2 tmp; }
efa2: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:2 tmp; }
efa2: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:2 tmp; }
efa2: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:2 tmp; }


efa4: offset0011 is offset0011 & mode1213=0 { export *[ram]:4 offset0011; }
efa4: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:4 tmp; }
efa4: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:4 tmp; }
efa4: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:4 tmp; }
efa4: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:4 tmp; }
efa4: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:4 tmp; }
efa4: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:4 tmp; }
efa4: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:4 tmp; }
efa4: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:4 tmp; }


efa8: offset0011 is offset0011 & mode1213=0 { export *[ram]:8 offset0011; }
efa8: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:8 tmp; }
efa8: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:8 tmp; }
efa8: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:8 tmp; }
efa8: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:8 tmp; }
efa8: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:8 tmp; }
efa8: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:8 tmp; }
efa8: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:8 tmp; }
efa8: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:8 tmp; }


# addc
:addc regS1, regS2, regSD is op2431=0x5b & op0710=0x0 & regS1 & regS2 & regSD unimpl


# addi
:addi regS1, regS2, regSD is op2431=0x59 & op0710=0x1 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS1 + regS2;
}


# addie
:addie regS1, regS2, regSD is op2431=0x7a & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addig
:addig regS1, regS2, regSD is op2431=0x79 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addige
:addige regS1, regS2, regSD is op2431=0x7b & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addil
:addil regS1, regS2, regSD is op2431=0x7c & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addile
:addile regS1, regS2, regSD is op2431=0x7e & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addine
:addine regS1, regS2, regSD is op2431=0x7d & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addino
:addino regS1, regS2, regSD is op2431=0x78 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addio
:addio regS1, regS2, regSD is op2431=0x7f & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addo
:addo regS1, regS2, regSD is op2431=0x59 & op0710=0x0 & regS1 & regS2 & regSD
{
	regSD = regS1 + regS2;
}


# addoe
:addoe regS1, regS2, regSD is op2431=0x7a & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	regSD = regS1 + regS2;
}


# addog
:addog regS1, regS2, regSD is op2431=0x79 & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	regSD = regS1 + regS2;
}


# addoge
:addoge regS1, regS2, regSD is op2431=0x7b & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	regSD = regS1 + regS2;
}


# addol
:addol regS1, regS2, regSD is op2431=0x7c & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	regSD = regS1 + regS2;
}


# addole
:addole regS1, regS2, regSD is op2431=0x7e & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	regSD = regS1 + regS2;
}


# addone
:addone regS1, regS2, regSD is op2431=0x7d & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	regSD = regS1 + regS2;
}


# addono
:addono regS1, regS2, regSD is op2431=0x78 & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (acCC) goto inst_next;
	regSD = regS1 + regS2;
}


# addoo
:addoo regS1, regS2, regSD is op2431=0x7f & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!acCC) goto inst_next;
	regSD = regS1 + regS2;
}


# addr
:addr regS1, regS2, regSD is op2431=0x78 & op0710=0xf & regS1 & regS2 & regSD unimpl


# addrl
:addrl regS1l, regS2l, regSDl is op2431=0x79 & op0710=0xf & regS1l & regS2l & regSDl unimpl


# alterbit
:alterbit regS1, regS2, regSD is op2431=0x58 & op0710=0xf & regS1 & regS2 & regSD unimpl


# and
:and regS1, regS2, regSD is op2431=0x58 & op0710=0x1 & regS1 & regS2 & regSD
{
	regSD = regS1 & regS2;
}


# andnot
:andnot regS1, regS2, regSD is op2431=0x58 & op0710=0x2 & regS1 & regS2 & regSD
{
	regSD = regS2 & ~regS1;
}


# atadd
:atadd regS1, regS2, regSD is op2431=0x61 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# atanr
:atanr regS1, regS2, regSD is op2431=0x68 & op0710=0x0 & regS1 & regS2 & regSD unimpl


# atanrl
:atanrl regS1l, regS2l, regSDl is op2431=0x69 & op0710=0x0 & regS1l & regS2l & regSDl unimpl


# atmod
:atmod regS1, regS2, regSD is op2431=0x61 & op0710=0x0 & regS1 & regS2 & regSD unimpl


# b
:b sdisp0223 is op2431=0x8 & op0000=0x0 & sdisp0223
{
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bal
:bal sdisp0223 is op2431=0xb & op0000=0x0 & sdisp0223
{
	g14 = inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];	
}


# balx
:balx efa1, reg1923 is ( op2431=0x85 & reg1923 ) ... & efa1
{
	local temp:4 = zext(efa1) << 2;
	reg1923 = inst_next;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bbc
:bbc cobrS1, cobrS2, sdisp0212 is op2431=0x30 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	if (((1<<cobrS1) & cobrS2) == 0) goto inst_next;
	ac[1,1] = 1;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];		
}


# bbs
:bbs cobrS1, cobrS2, sdisp0212 is op2431=0x37 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	if (((1<<cobrS1) & cobrS2) != 0) goto inst_next;
	ac[1,1] = 1;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];		
}


# be
:be sdisp0223 is op2431=0x12 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bg
:bg sdisp0223 is op2431=0x11 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bge
:bge sdisp0223 is op2431=0x13 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bl
:bl sdisp0223 is op2431=0x14 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# ble
:ble sdisp0223 is op2431=0x16 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bne
:bne sdisp0223 is op2431=0x15 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}

# bno
:bno sdisp0223 is op2431=0x10 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (acCC) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}

# bo
:bo sdisp0223 is op2431=0x17 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!acCC) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}

# bswap
:bswap regS1, regSD is m1=0x1 & op2431=0x5a & op0710=0xd & regS1 & regSD unimpl


# bx
:bx efa1 is ( op2431=0x84 ) ... & efa1
{
	local temp:4 = zext(efa1) << 2;
	goto [temp];
}


# call
:call sdisp0223 is op2431=0x9 & op0000=0x0 & sdisp0223
{
	rip = inst_next;
	pfp = fp;
	fp = (sp + ($(SALIGN) * 16 - 1)) & ~($(SALIGN) * 16 - 1);
	sp = fp + 64;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	pfp = fp;
	call [temp];	
}


# calls
:calls regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x0 & regS1 unimpl


# callx
:callx efa1 is ( op2431=0x86 ) ... & efa1
{
	rip = inst_next;
	pfp = fp;
	fp = (sp + ($(SALIGN) * 16 - 1)) & ~($(SALIGN) * 16 - 1);
	sp = fp + 64;
	local temp:4 = zext(efa1) << 2;
	pfp = fp;
	call [temp];	
}


# chkbit
:chkbit regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0xe & regS1 & regS2 unimpl


# classr
:classr regS1 is m1=0x1 & m2=0x1 & op2431=0x68 & op0710=0xf & regS1 unimpl


# classrl
:classrl regS1l is m1=0x1 & m2=0x1 & op2431=0x69 & op0710=0xf & regS1l unimpl


# clrbit
:clrbit regS1, regS2, regSD is op2431=0x58 & op0710=0xc & regS1 & regS2 & regSD unimpl


# cmpdeci
:cmpdeci regS1, regS2, regSD is op2431=0x5a & op0710=0x7 & regS1 & regS2 & regSD
{
	ac[0,3] = 0;
	ac[2,1] = regS1 s< regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 s> regS2;	
	regSD = regS2 - 1;
}


# cmpdeco
:cmpdeco regS1, regS2, regSD is op2431=0x5a & op0710=0x6 & regS1 & regS2 & regSD
{
	ac[0,3] = 0;
	ac[2,1] = regS1 < regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 > regS2;	
	regSD = regS2 - 1;	
}


# cmpi
:cmpi regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0x1 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1 s< regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 s> regS2;	
}


# cmpib
:cmpib regS1, regS2 is m2=0x1 & op2431=0x59 & op0710=0x5 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1:1 s< regS2:1;
	ac[1,1] = regS1:1 == regS2:1;
	ac[0,1] = regS1:1 s> regS2:1;	
}


# cmpibe
:cmpibe cobrS1, cobrS2, sdisp0212 is op2431=0x3a & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibg
:cmpibg cobrS1, cobrS2, sdisp0212 is op2431=0x39 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}



# cmpibge
:cmpibge cobrS1, cobrS2, sdisp0212 is op2431=0x3b & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibl
:cmpibl cobrS1, cobrS2, sdisp0212 is op2431=0x3c & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpible
:cmpible cobrS1, cobrS2, sdisp0212 is op2431=0x3e & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibne
:cmpibne cobrS1, cobrS2, sdisp0212 is op2431=0x3d & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibno
:cmpibno cobrS1, cobrS2, sdisp0212 is op2431=0x38 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (acCC) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibo
:cmpibo cobrS1, cobrS2, sdisp0212 is op2431=0x3f & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!acCC) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpinci
:cmpinci regS1, regS2, regSD is op2431=0x5a & op0710=0x5 & regS1 & regS2 & regSD
{
	ac[0,3] = 0;
	ac[2,1] = regS1 s< regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 s> regS2;	
	regSD = regS2 + 1;
}


# cmpinco
:cmpinco regS1, regS2, regSD is op2431=0x5a & op0710=0x4 & regS1 & regS2 & regSD
{
	ac[0,3] = 0;
	ac[2,1] = regS1 < regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 > regS2;	
	regSD = regS2 - 1;
}


# cmpis
:cmpis regS1, regS2 is m2=0x1 & op2431=0x59 & op0710=0x7 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1:2 s< regS2:2;
	ac[1,1] = regS1:2 == regS2:2;
	ac[0,1] = regS1:2 s> regS2:2;
}


# cmpo
:cmpo regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0x0 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1 < regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 > regS2;
}


# cmpob
:cmpob regS1, regS2 is m2=0x1 & op2431=0x59 & op0710=0x4 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1:1 < regS2:1;
	ac[1,1] = regS1:1 == regS2:1;
	ac[0,1] = regS1:1 > regS2:1;
}


# cmpobe
:cmpobe cobrS1, cobrS2, sdisp0212 is op2431=0x32 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpobg
:cmpobg cobrS1, cobrS2, sdisp0212 is op2431=0x31 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpobge
:cmpobge cobrS1, cobrS2, sdisp0212 is op2431=0x33 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}

# cmpobl
:cmpobl cobrS1, cobrS2, sdisp0212 is op2431=0x34 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpoble
:cmpoble cobrS1, cobrS2, sdisp0212 is op2431=0x36 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpobne
:cmpobne cobrS1, cobrS2, sdisp0212 is op2431=0x35 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpor
:cmpor regS1, regS2 is m2=0x1 & op2431=0x68 & op0710=0x4 & regS1 & regS2 unimpl


# cmporl
:cmporl regS1l, regS2l is m2=0x1 & op2431=0x69 & op0710=0x4 & regS1l & regS2l unimpl


# cmpos
:cmpos regS1, regS2 is m2=0x1 & op2431=0x59 & op0710=0x6 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1:2 < regS2:2;
	ac[1,1] = regS1:2 == regS2:2;
	ac[0,1] = regS1:2 > regS2:2;
}


# cmpr
:cmpr regS1, regS2 is m2=0x1 & op2431=0x68 & op0710=0x5 & regS1 & regS2 unimpl


# cmprl
:cmprl regS1l, regS2l is m2=0x1 & op2431=0x69 & op0710=0x5 & regS1l & regS2l unimpl


# cmpstr
:cmpstr regS1, regS2, regSD is op2431=0x60 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# concmpi
:concmpi regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0x3 & regS1 & regS2
{
	if ((ac & 4) == 0) goto inst_next;
	ac[0,3] = 0;
	ac[1,1] = regS1 s<= regS2;
	ac[0,1] = regS1 s> regS2;
}


# concmpo
:concmpo regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0x2 & regS1 & regS2
{
	if ((ac & 4) == 0) goto inst_next;
	ac[0,3] = 0;
	ac[1,1] = regS1 <= regS2;
	ac[0,1] = regS1 > regS2;
}


# condrec
:condrec regS1, regSD is m1=0x1 & op2431=0x64 & op0710=0x6 & regS1 & regSD unimpl


# condwait
:condwait regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x8 & regS1 unimpl


# cosr
:cosr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xd & regS1 & regSD unimpl


# cosrl
:cosrl regS1l, regSDl is m1=0x1 & op2431=0x69 & op0710=0xd & regS1l & regSDl unimpl


# cpyrsre
#TODO  tq
# :cpyrsre regS1tq, regS2tq, regSDtq is op2431=0x6e & op0710=0x3 & regS1tq & regS2tq & regSDtq unimpl


# cpysre
#TODO  tq
# :cpysre regS1tq, regS2tq, regSDtq is op2431=0x6e & op0710=0x2 & regS1tq & regS2tq & regSDtq unimpl


# cvtadr
:cvtadr regS1, regSDl is m1=0x1 & op2431=0x67 & op0710=0x2 & regS1 & regSDl unimpl


# cvtilr
:cvtilr regS1, regSD is m1=0x1 & op2431=0x67 & op0710=0x5 & regS1 & regSD unimpl


# cvtir
:cvtir regS1, regSD is m1=0x1 & op2431=0x67 & op0710=0x4 & regS1 & regSD unimpl


# cvtri
:cvtri regS1, regSD is m1=0x1 & op2431=0x6c & op0710=0x0 & regS1 & regSD unimpl


# cvtril
:cvtril regS1, regSDl is m1=0x1 & op2431=0x6c & op0710=0x1 & regS1 & regSDl unimpl


# cvtzri
:cvtzri regS1, regSD is m1=0x1 & op2431=0x6c & op0710=0x2 & regS1 & regSD unimpl


# cvtzril
:cvtzril regS1, regSDl is m1=0x1 & op2431=0x6c & op0710=0x3 & regS1 & regSDl unimpl


# daddc
:daddc regS1, regS2, regSD is op2431=0x64 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# dcctl
:dcctl regS1, regS2, regSD is op2431=0x65 & op0710=0xc & regS1 & regS2 & regSD unimpl


# dcinva
:dcinva efa1 is ( op2431=0xac ) ... & efa1 unimpl


# divi
:divi regS1, regS2, regSD is op2431=0x74 & op0710=0xb & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 s/ regS1;
}


# divo
:divo regS1, regS2, regSD is op2431=0x70 & op0710=0xb & regS1 & regS2 & regSD
{
	regSD = regS2 / regS1;
}


# divr
:divr regS1, regS2, regSD is op2431=0x78 & op0710=0xb & regS1 & regS2 & regSD unimpl


# divrl
:divrl regS1l, regS2l, regSDl is op2431=0x79 & op0710=0xb & regS1l & regS2l & regSDl unimpl


# dmovt
:dmovt regS1, regSD is m1=0x1 & op2431=0x64 & op0710=0x4 & regS1 & regSD unimpl


# dsubc
:dsubc regS1, regS2, regSD is op2431=0x64 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# ediv
:ediv regS1, regS2l, regSD is op2431=0x67 & op0710=0x1 & regS1 & regS2l & regSD unimpl


# emul
:emul regS1, regS2, regSDl is op2431=0x67 & op0710=0x0 & regS1 & regS2 & regSDl unimpl


# eshro
:eshro regS1, regS2, regSD is op2431=0x5d & op0710=0x8 & regS1 & regS2 & regSD unimpl


# expr
:expr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0x9 & regS1 & regSD unimpl


# exprl
:exprl regS1l, regSDl is m1=0x1 & op2431=0x69 & op0710=0x9 & regS1l & regSDl unimpl


# extract
:extract regS1, regS2, regSD is op2431=0x65 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# faulte
:faulte  is op2431=0x1a & op0000=0x0 unimpl


# faultg
:faultg  is op2431=0x19 & op0000=0x0 unimpl


# faultge
:faultge  is op2431=0x1b & op0000=0x0 unimpl


# faultl
:faultl  is op2431=0x1c & op0000=0x0 unimpl


# faultle
:faultle  is op2431=0x1e & op0000=0x0 unimpl


# faultne
:faultne  is op2431=0x1d & op0000=0x0 unimpl


# faultno
:faultno  is op2431=0x18 & op0000=0x0 unimpl


# faulto
:faulto  is op2431=0x1f & op0000=0x0 unimpl


# fill
:fill regS1, regS2, regSD is op2431=0x61 & op0710=0x7 & regS1 & regS2 & regSD unimpl


# flushreg
:flushreg  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xd unimpl


# fmark
:fmark  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xc unimpl


# halt
:halt regS1 is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x65 & op0710=0xd & regS1 unimpl


# icctl
:icctl regS1, regS2, regSD is op2431=0x65 & op0710=0xb & regS1 & regS2 & regSD unimpl


# inspacc
:inspacc regS1, regSD is m1=0x1 & op2431=0x61 & op0710=0x3 & regS1 & regSD unimpl


# intctl
:intctl regS1, regSD is m1=0x1 & op2431=0x65 & op0710=0x8 & regS1 & regSD unimpl


# intdis
:intdis  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x5b & op0710=0x4 unimpl


# inten
:inten  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x5b & op0710=0x5 unimpl


# ld
:ld efa4, reg1923 is ( op2431=0x90 & reg1923 ) ... & efa4
{
	reg1923 = efa4;
}


# lda
:lda efa1, reg1923 is ( op2431=0x8c & reg1923 ) ... & efa1
{
	reg1923 = zext(efa1);
}


# ldib
:ldib efa1, reg1923 is ( op2431=0xc0 & reg1923 ) ... & efa1
{
	reg1923 = sext(efa1);
}


# ldis
:ldis efa2, reg1923 is ( op2431=0xc8 & reg1923 ) ... & efa2
{
	reg1923 = sext(efa2);
}


# ldl
:ldl efa8, reg1923l is ( op2431=0x98 & reg1923l ) ... & efa8
{
	reg1923l = efa8;
}


# ldob
:ldob efa1, reg1923 is ( op2431=0x80 & reg1923 ) ... & efa1
{
	reg1923 = zext(efa1);
}


# ldos
:ldos efa2, reg1923 is ( op2431=0x88 & reg1923 ) ... & efa2
{
	reg1923 = zext(efa2);
}


# ldphy
:ldphy regS1, regSD is m1=0x1 & op2431=0x61 & op0710=0x4 & regS1 & regSD unimpl


# ldq
:ldq efa16, reg1923q is ( op2431=0xb0 & reg1923q ) ... & efa16
{
	reg1923q = efa16;
}


# ldt
:ldt efa12, reg1923t is ( op2431=0xa0 & reg1923t ) ... & efa12
{
	reg1923t = efa12;
}


# ldtime
:ldtime regSDl is m0=0x1 & m1=0x1 & op2431=0x67 & op0710=0x3 & regSDl unimpl


# logbnr
:logbnr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xa & regS1 & regSD unimpl


# logbnrl
:logbnrl regS1l, regSDl is m1=0x1 & op2431=0x69 & op0710=0xa & regS1l & regSDl unimpl


# logepr
:logepr regS1, regS2, regSD is op2431=0x68 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# logeprl
:logeprl regS1l, regS2l, regSDl is op2431=0x69 & op0710=0x1 & regS1l & regS2l & regSDl unimpl


# logr
:logr regS1, regS2, regSD is op2431=0x68 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# logrl
:logrl regS1l, regS2l, regSDl is op2431=0x69 & op0710=0x2 & regS1l & regS2l & regSDl unimpl


# mark
:mark  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xb unimpl


# modac
:modac regS1, regS2, regSD is op2431=0x64 & op0710=0x5 & regS1 & regS2 & regSD unimpl


# modi
:modi regS1, regS2, regSD is op2431=0x74 & op0710=0x9 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 s/ regS1;
}


# modify
:modify regS1, regS2, regSD is op2431=0x65 & op0710=0x0 & regS1 & regS2 & regSD
{
	regSD = (regS2 & regS1) | (regSD & ~regS1);
}


# modpc
:modpc regS1, regS2, regSD is op2431=0x65 & op0710=0x5 & regS1 & regS2 & regSD unimpl


# modtc
:modtc regS1, regS2, regSD is op2431=0x65 & op0710=0x4 & regS1 & regS2 & regSD unimpl


# mov
:mov regS1, regSD is m1=0x1 & op2431=0x5c & op0710=0xc & regS1 & regSD
{
	regSD = regS1;
}


# movl
:movl regS1l, regSDl is m1=0x1 & op2431=0x5d & op0710=0xc & regS1l & regSDl
{
	local tmp:8 = regS1l;
	regSDl = tmp;
}


# movq
:movq regS1q, regSDq is m1=0x1 & op2431=0x5f & op0710=0xc & regS1q & regSDq
{
	local tmp:16 = regS1q;
	regSDq = tmp;
}


# movqstr
:movqstr regS1, regS2, regSD is op2431=0x60 & op0710=0x4 & regS1 & regS2 & regSD unimpl


# movr
:movr regS1, regSD is m1=0x1 & op2431=0x6c & op0710=0x9 & regS1 & regSD unimpl


# movre
#TODO  tq
# :movre regS1tq, regSDtq is m1=0x1 & op2431=0x6e & op0710=0x1 & regS1tq & regSDtq unimpl


# movrl
:movrl regS1l, regSDl is m1=0x1 & op2431=0x6d & op0710=0x9 & regS1l & regSDl unimpl


# movstr
:movstr regS1, regS2, regSD is op2431=0x60 & op0710=0x5 & regS1 & regS2 & regSD unimpl


# movt
:movt regS1t, regSDt is m1=0x1 & op2431=0x5e & op0710=0xc & regS1t & regSDt
{
	local tmp:12 = regS1t;
	regSDt = tmp;
}


# muli
:muli regS1, regS2, regSD is op2431=0x74 & op0710=0x1 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS1 * regS2;
}


# mulo
:mulo regS1, regS2, regSD is op2431=0x70 & op0710=0x1 & regS1 & regS2 & regSD
{
	regSD = regS1 * regS2;
}


# mulr
:mulr regS1, regS2, regSD is op2431=0x78 & op0710=0xc & regS1 & regS2 & regSD unimpl


# mulrl
:mulrl regS1l, regS2l, regSDl is op2431=0x79 & op0710=0xc & regS1l & regS2l & regSDl unimpl


# nand
:nand regS1, regS2, regSD is op2431=0x58 & op0710=0xe & regS1 & regS2 & regSD
{
	regSD = ~regS1 | ~regS2;
}


# nor
:nor regS1, regS2, regSD is op2431=0x58 & op0710=0x8 & regS1 & regS2 & regSD
{
	regSD = ~regS1 & ~regS2;
}


# not
:not regS1, regSD is m1=0x1 & op2431=0x58 & op0710=0xa & regS1 & regSD
{
	regSD = ~regS1;
}


# notand
:notand regS1, regS2, regSD is op2431=0x58 & op0710=0x4 & regS1 & regS2 & regSD
{
	regSD = ~(regS1 & regS2);
}


# notbit
:notbit regS1, regS2, regSD is op2431=0x58 & op0710=0x0 & regS1 & regS2 & regSD unimpl


# notor
:notor regS1, regS2, regSD is op2431=0x58 & op0710=0xd & regS1 & regS2 & regSD
{
	regSD = ~regS2 | regS1;
}


# or
:or regS1, regS2, regSD is op2431=0x58 & op0710=0x7 & regS1 & regS2 & regSD
{
	regSD = regS2 | regS1;
}


# ornot
:ornot regS1, regS2, regSD is op2431=0x58 & op0710=0xb & regS1 & regS2 & regSD
{
	regSD = regS2 | ~regS1;
}


# receive
:receive regS1, regSD is m1=0x1 & op2431=0x65 & op0710=0x6 & regS1 & regSD unimpl


# remi
:remi regS1, regS2, regSD is op2431=0x74 & op0710=0x8 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 s% regS2;
}


# remo
:remo regS1, regS2, regSD is op2431=0x70 & op0710=0x8 & regS1 & regS2 & regSD
{
	regSD = regS2 % regS1;
}


# remr
:remr regS1, regS2, regSD is op2431=0x68 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# remrl
:remrl regS1l, regS2l, regSDl is op2431=0x69 & op0710=0x3 & regS1l & regS2l & regSDl unimpl


# resumprcs
:resumprcs regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x4 & regS1 unimpl


# ret
:ret  is op2431=0xa & op0000=0x0
{
	fp = pfp;
	return [rip];
}


# rotate
:rotate regS1, regS2, regSD is op2431=0x59 & op0710=0xd & regS1 & regS2 & regSD unimpl


# roundr
:roundr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xb & regS1 & regSD unimpl


# roundrl
:roundrl regS1l, regSDl is m1=0x1 & op2431=0x69 & op0710=0xb & regS1l & regSDl unimpl


# saveprcs
:saveprcs  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x6 unimpl


# scaler
:scaler regS1, regS2, regSD is op2431=0x67 & op0710=0x7 & regS1 & regS2 & regSD unimpl


# scalerl
:scalerl regS1, regS2l, regSDl is op2431=0x67 & op0710=0x6 & regS1 & regS2l & regSDl unimpl


# scanbit
:scanbit regS1, regSD is m1=0x1 & op2431=0x64 & op0710=0x1 & regS1 & regSD unimpl


# scanbyte
:scanbyte regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0xc & regS1 & regS2
{
	ac[0,3] = 0;
	local code = (regS1[24,8] == regS2[24,8]) ||
	      	     (regS1[16,8] == regS2[16,8]) ||
		     (regS1[8,8] == regS2[8,8]) ||
		     (regS1[0,8] == regS2[0,8]);
	ac[1,1] = code; 
}


# schedprcs
:schedprcs regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x5 & regS1 unimpl


# sdma
:sdma regS1, regS2, regSD is op2431=0x63 & op0710=0x0 & regS1 & regS2 & regSD unimpl


# sele
:sele regS1, regS2, regSD is op2431=0x7a & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 2) == 0) goto inst_next;
	regSD = regS2;
}


# selg
:selg regS1, regS2, regSD is op2431=0x79 & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 1) == 0) goto inst_next;
	regSD = regS2;
}


# selge
:selge regS1, regS2, regSD is op2431=0x7b & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 3) == 0) goto inst_next;
	regSD = regS2;
}


# sell
:sell regS1, regS2, regSD is op2431=0x7c & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 4) == 0) goto inst_next;
	regSD = regS2;
}


# selle
:selle regS1, regS2, regSD is op2431=0x7e & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 6) == 0) goto inst_next;
	regSD = regS2;
}


# selne
:selne regS1, regS2, regSD is op2431=0x7d & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 5) == 0) goto inst_next;
	regSD = regS2;
}


# selno
:selno regS1, regS2, regSD is op2431=0x78 & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if (acCC != 0) goto inst_next;
	regSD = regS2;
}


# selo
:selo regS1, regS2, regSD is op2431=0x7f & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if (acCC == 0) goto inst_next;
	regSD = regS2;
}


# send
:send regS1, regS2, regSD is op2431=0x66 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# sendserv
:sendserv regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x3 & regS1 unimpl


# setbit
:setbit regS1, regS2, regSD is op2431=0x58 & op0710=0x3 & regS1 & regS2 & regSD
{
	regSD = regS2 | (1 << regS1);
}


# shli
:shli regS1, regS2, regSD is op2431=0x59 & op0710=0xe & regS1 & regS2 & regSD
{
	#TODO  overflow
	regSD = regS2 << regS1;
}


# shlo
:shlo regS1, regS2, regSD is op2431=0x59 & op0710=0xc & regS1 & regS2 & regSD
{
	regSD = regS2 << regS1;
}


# shrdi
:shrdi regS1, regS2, regSD is op2431=0x59 & op0710=0xa & regS1 & regS2 & regSD
{
	#TODO  are there flags here?
	#TODO  is this correct?
	# (x + ((x >> 31) & ((1 << n) + ~0))) >> n
	regSD = (regS2 + ((regS2 s>> 31) & ((1 << regS1) + ~0))) s>> regS1;
}


# shri
:shri regS1, regS2, regSD is op2431=0x59 & op0710=0xb & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 s>> regS1;
}


# shro
:shro regS1, regS2, regSD is op2431=0x59 & op0710=0x8 & regS1 & regS2 & regSD
{
	regSD = regS2 >> regS1;
}


# signal
:signal regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xa & regS1 unimpl


# sinr
:sinr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xc & regS1 & regSD unimpl


# sinrl
:sinrl regS1l, regSDl is m1=0x1 & op2431=0x69 & op0710=0xc & regS1l & regSDl unimpl


# spanbit
:spanbit regS1, regSD is m1=0x1 & op2431=0x64 & op0710=0x0 & regS1 & regSD unimpl


# sqrtr
:sqrtr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0x8 & regS1 & regSD unimpl


# sqrtrl
:sqrtrl regS1l, regSDl is m1=0x1 & op2431=0x69 & op0710=0x8 & regS1l & regSDl unimpl


# st
:st reg1923, efa4 is ( op2431=0x92 & reg1923 ) ... & efa4
{
	efa4 = reg1923;
}


# stib
:stib reg1923, efa1 is ( op2431=0xc2 & reg1923 ) ... & efa1
{
	efa1 = reg1923:1;
}


# stis
:stis reg1923, efa2 is ( op2431=0xca & reg1923 ) ... & efa2
{
	efa2 = reg1923:2;
}


# stl
:stl reg1923l, efa8 is ( op2431=0x9a & reg1923l ) ... & efa8
{
	efa8 = reg1923l;
}


# stob
:stob reg1923, efa1 is ( op2431=0x82 & reg1923 ) ... & efa1
{
	efa1 = reg1923:1;
}


# stos
:stos reg1923, efa2 is ( op2431=0x8a & reg1923 ) ... & efa2
{
	efa2 = reg1923:2;
}


# stq
:stq reg1923q, efa16 is ( op2431=0xb2 & reg1923q ) ... & efa16
{
	efa16 = reg1923q;
}


# stt
:stt reg1923t, efa12 is ( op2431=0xa2 & reg1923t ) ... & efa12
{
	efa12 = reg1923t;
}


# subc
:subc regS1, regS2, regSD is op2431=0x5b & op0710=0x2 & regS1 & regS2 & regSD
{
	local tmp:4 = zext(ac[1,1]);
	ac[2,1] = 0;
	ac[1,1] = ((regS1 - 1) + tmp) > regS2;
	ac[0,1] = ((regS1 - 1) + tmp) s> regS2;
	regSD = regS2 + (regS1 - 1) + tmp;
}


# subi
:subi regS1, regS2, regSD is op2431=0x59 & op0710=0x3 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 - regS1;
}


# subie
:subie regS1, regS2, regSD is op2431=0x7a & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subig
:subig regS1, regS2, regSD is op2431=0x79 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subige
:subige regS1, regS2, regSD is op2431=0x7b & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subil
:subil regS1, regS2, regSD is op2431=0x7c & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subile
:subile regS1, regS2, regSD is op2431=0x7e & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subine
:subine regS1, regS2, regSD is op2431=0x7d & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subino
:subino regS1, regS2, regSD is op2431=0x78 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subio
:subio regS1, regS2, regSD is op2431=0x7f & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subo
:subo regS1, regS2, regSD is op2431=0x59 & op0710=0x2 & regS1 & regS2 & regSD
{
	regSD = regS2 - regS1;
}


# suboe
:suboe regS1, regS2, regSD is op2431=0x7a & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	regSD = regS2 - regS1;
}


# subog
:subog regS1, regS2, regSD is op2431=0x79 & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	regSD = regS2 - regS1;
}


# suboge
:suboge regS1, regS2, regSD is op2431=0x7b & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	regSD = regS2 - regS1;
}


# subol
:subol regS1, regS2, regSD is op2431=0x7c & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	regSD = regS2 - regS1;
}


# subole
:subole regS1, regS2, regSD is op2431=0x7e & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	regSD = regS2 - regS1;
}


# subone
:subone regS1, regS2, regSD is op2431=0x7d & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	regSD = regS2 - regS1;
}


# subono
:subono regS1, regS2, regSD is op2431=0x78 & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (acCC) goto inst_next;
	regSD = regS2 - regS1;
}


# suboo
:suboo regS1, regS2, regSD is op2431=0x7f & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	regSD = regS2 - regS1;
}


# subr
:subr regS1, regS2, regSD is op2431=0x78 & op0710=0xd & regS1 & regS2 & regSD unimpl


# subrl
:subrl regS1l, regS2l, regSDl is op2431=0x79 & op0710=0xd & regS1l & regS2l & regSDl unimpl


# syncf
:syncf  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xf unimpl


# synld
:synld regS1, regSD is m1=0x1 & op2431=0x61 & op0710=0x5 & regS1 & regSD
{
	#TODO  this might need work
	regSD = *[ram]:4 regS1;
}


# synmov
:synmov regS1, regS2 is m2=0x1 & op2431=0x60 & op0710=0x0 & regS1 & regS2
{
	#TODO  this might need work
	*[ram]:4 regS1 = *[ram]:4 regS2;
}


# synmovl
:synmovl regS1, regS2 is m2=0x1 & op2431=0x60 & op0710=0x1 & regS1 & regS2
{
	#TODO  this might need work
	*[ram]:8 regS1 = *[ram]:8 regS2;
}


# synmovq
:synmovq regS1, regS2 is m2=0x1 & op2431=0x60 & op0710=0x2 & regS1 & regS2
{
	#TODO  this might need work
	*[ram]:16 regS1 = *[ram]:16 regS2;
}


# syscall
:syscall  is op2431=0x1 & op0000=0x0 unimpl


# sysctl
:sysctl regS1, regS2, regSD is op2431=0x65 & op0710=0x9 & regS1 & regS2 & regSD unimpl


# tanr
:tanr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xe & regS1 & regSD unimpl


# tanrl
:tanrl regS1l, regSDl is m1=0x1 & op2431=0x69 & op0710=0xe & regS1l & regSDl unimpl


# teste
:teste cobrSD is op2431=0x22 & cobrSD
{
	cobrSD = zext((ac & 2) != 0);
}


# testg
:testg cobrSD is op2431=0x21 & cobrSD
{
	cobrSD = zext((ac & 1) != 0);
}


# testge
:testge cobrSD is op2431=0x23 & cobrSD
{
	cobrSD = zext((ac & 3) != 0);
}


# testl
:testl cobrSD is op2431=0x24 & cobrSD
{
	cobrSD = zext((ac & 4) != 0);
}


# testle
:testle cobrSD is op2431=0x26 & cobrSD
{
	cobrSD = zext((ac & 6) != 0);
}


# testne
:testne cobrSD is op2431=0x25 & cobrSD
{
	cobrSD = zext((ac & 5) != 0);
}


# testno
:testno cobrSD is op2431=0x20 & cobrSD
{
	cobrSD = zext((ac & 7) == 0);
}


# testo
:testo cobrSD is op2431=0x27 & cobrSD
{
	cobrSD = zext((ac & 7) != 0);
}


# udma
:udma  is op2431=0x63 & op0710=0x1 unimpl


# wait
:wait regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x9 & regS1 unimpl


# xnor
:xnor regS1, regS2, regSD is op2431=0x58 & op0710=0x9 & regS1 & regS2 & regSD
{
	regSD = ~(regS1 | regS2) | (regS1 & regS2);
}


# xor
:xor regS1, regS2, regSD is op2431=0x58 & op0710=0x6 & regS1 & regS2 & regSD
{
	regSD = regS1 ^ regS2;
}


