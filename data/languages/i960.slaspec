# i960 / 80960


define endian=little;

define alignment=4;

define space ram type=ram_space size=4 default;

define space register type=register_space size=4;

@define SALIGN 1

define register offset=0 size=4 [ pfp sp rip r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 g10 g11 g12 g13 g14 fp ];

define register offset=0x100 size=4 [ sf0 sf1 sf2 sf3 sf4 sf5 sf6 sf7 sf8 sf9 sf10 sf11 sf12 sf13 sf14 sf15 sf16 sf17 sf18 sf19 sf20 sf21 sf22 sf23 sf24 sf25 sf26 sf27 sf28 sf29 sf30 sf31 ];


define register offset=0x200 size=4 [ pc ac ip tc ];


# 80-bit registers  extended-real format
define register offset=0x300 size=10 [ fp0 fp1 fp2 fp3 ];



define token instr (32)
  op2431=(24,31)
  freg1923=(19,23)
  reg1923=(19,23)
  sfr1923=(19,23)
  fp1923=(19,23)
  op1923=(19,23)
  freg1418=(14,18)
  reg1418=(14,18)
  sfr1418=(14,18)
  fp1418=(14,18)
  op1418=(14,18)
  m2=(13,13)
  m1=(12,12)
  m0=(11,11)
  op0710=(7,10)
  s1=(6,6)
  s0=(5,5)
  freg0004=(0,4)
  reg0004=(0,4)
  sfr0004=(0,4)
  fp0004=(0,4)
  op0004=(0,4)
  sdisp0212=(2,12) signed
  t=(1,1)
  s2=(0,0)
  sdisp0223=(2,23) signed
  op0000=(0,0)
  mode1213=(12,13)
  mode1011=(10,11)
  offset0011=(0,11)
  scale=(7,9)
  op0506=(5,6)
;


define token instr2 (32)
  sdisp0031=(0,31) signed
;



attach variables [ reg0004 reg1418 reg1923 ]
                 [ pfp sp rip r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 g10 g11 g12 g13 g14 fp ];

attach variables [ sfr0004 sfr1418 sfr1923 ]
                 [ sf0 sf1 sf2 sf3 sf4 sf5 sf6 sf7 sf8 sf9 sf10 sf11 sf12 sf13 sf14 sf15 sf16 sf17 sf18 sf19 sf20 sf21 sf22 sf23 sf24 sf25 sf26 sf27 sf28 sf29 sf30 sf31 ];

attach variables [ freg0004 freg1418 freg1923 ]
                 [ fp0 fp1 fp2 fp3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ];


#TODO CC    appears to be:  (mask & cc || mask == cc)
# 010 true
# 000 false
# 000 unordered
# 001 gt
# 010 eq
# 100 lt
# 01X carry out
# 0X1 overflow


regS1: reg0004 is reg0004 & m2 & m1 & m0=0 & s1 & s0=0 { local tmp:4 = reg0004; export tmp; }
regS1: op0004 is op0004 & m2 & m1 & m0=1 & s1 & s0=0 { local tmp:4 = op0004; export tmp; }
regS1: sfr0004 is sfr0004 & m2 & m1 & m0=0 & s1 & s0=1 { local tmp:4 = sfr0004; export tmp; }
regS2: reg1418 is reg1418 & m2 & m1=0 & m0 & s1=0 & s0 { export reg1418; }
regS2: op1418 is op1418 & m2 & m1=1 & m0 & s1=0 & s0 { local tmp:4 = op1418; export tmp; }
regS2: sfr1418 is sfr1418 & m2 & m1=0 & m0 & s1=1 & s0 { export sfr1418; }
regSD: reg1923 is reg1923 & m2=0 & m1 & m0 & s1 & s0 { export reg1923; }
cobrS1: reg0004 is reg0004 & m2=0 & s2=0 & t { export reg0004; }
cobrS2: reg1418 is reg1418 & m2=0 & s2=0 & t { export reg1418; }
cobrSD:  reg1923 is reg1923 & m2=0 & s2=0 & t { export reg1923; }
cobrS1: op0004 is op0004 & m2=1 & s2=0 & t { export op0004; }
cobrS2: reg1418 is reg1418 & m2=1 & s2=0 & t { export reg1418; }
cobrSD:  reg1923 is reg1923 & m2=1 & s2=0 & t { export reg1923; }
cobrS1: reg0004 is reg0004 & m2=0 & s2=1 & t { export reg0004; }
cobrS2: sfr1418 is sfr1418 & m2=0 & s2=1 & t { export sfr1418; }
cobrSD:  sfr1923 is sfr1923 & m2=0 & s2=1 & t { export sfr1923; }
cobrS1: op0004 is op0004 & m2=1 & s2=0 & t=0 { export op0004; }
cobrS2: sfr1418 is sfr1418 & m2=1 & s2=1 & t=0 { export sfr1418; }
cobrSD:  sfr1923 is sfr1923 & m2=1 & s2=1 & t=0 { export sfr1923; }

#TODO  floating-point needs work
#TODO  these must export the same size, so not sure how to handle
#      that with the automatic conversion this chip does.  that might
#      mean alot of duplicate instructions with m0=1|0 or can the int2float
#      go right here and that will make sense... think so???
# fregS1: reg0004 is reg0004 & m2 & m1 & m0=0 & s1 & s0=0 { export reg0004; }
# fregS1: freg0004 is freg0004 & m2 & m1 & m0=1 & s1 & s0=0 & op0004 < 4 { export freg0004;}
# fregS1: 0.0 is freg0004 & m2 & m1 & m0=1 & s1 & s0=0 & op0004 = 0x10 { local tmp = 0.0; export tmp; }
# fregS1: 1.0 is freg0004 & m2 & m1 & m0=1 & s1 & s0=0 & op0004 = 0x1f { local tmp = 1.0; export tmp; }




efa1: offset0011 is offset0011 & mode1213=0 { export *[ram]:1 offset0011; }
efa1: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:1 tmp; }
efa1: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:1 tmp; }
efa1: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:1 tmp; }
efa1: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:1 tmp; }
efa1: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:1 tmp; }
efa1: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:1 tmp; }
efa1: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:1 tmp; }
efa1: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:1 tmp; }


efa12: offset0011 is offset0011 & mode1213=0 { export *[ram]:12 offset0011; }
efa12: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:12 tmp; }
efa12: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:12 tmp; }
efa12: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:12 tmp; }
efa12: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:12 tmp; }
efa12: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:12 tmp; }
efa12: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:12 tmp; }
efa12: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:12 tmp; }
efa12: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:12 tmp; }


efa16: offset0011 is offset0011 & mode1213=0 { export *[ram]:16 offset0011; }
efa16: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:16 tmp; }
efa16: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:16 tmp; }
efa16: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:16 tmp; }
efa16: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:16 tmp; }
efa16: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:16 tmp; }
efa16: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:16 tmp; }
efa16: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:16 tmp; }
efa16: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:16 tmp; }


efa2: offset0011 is offset0011 & mode1213=0 { export *[ram]:2 offset0011; }
efa2: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:2 tmp; }
efa2: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:2 tmp; }
efa2: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:2 tmp; }
efa2: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:2 tmp; }
efa2: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:2 tmp; }
efa2: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:2 tmp; }
efa2: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:2 tmp; }
efa2: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:2 tmp; }


efa4: offset0011 is offset0011 & mode1213=0 { export *[ram]:4 offset0011; }
efa4: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:4 tmp; }
efa4: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:4 tmp; }
efa4: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:4 tmp; }
efa4: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:4 tmp; }
efa4: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:4 tmp; }
efa4: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:4 tmp; }
efa4: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:4 tmp; }
efa4: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:4 tmp; }


efa8: offset0011 is offset0011 & mode1213=0 { export *[ram]:8 offset0011; }
efa8: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:8 tmp; }
efa8: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:8 tmp; }
efa8: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sdisp0031 [ reloc = sdisp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:8 tmp; }
efa8: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:8 tmp; }
efa8: sdisp0031 is mode1213=3 & mode1011=0 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031; export *[ram]:8 tmp; }
efa8: sdisp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418; export *[ram]:8 tmp; }
efa8: sdisp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + (reg0004 * scale); export *[ram]:8 tmp; }
efa8: sdisp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sdisp0031 { local tmp:4 = sdisp0031 + reg1418 + (reg0004 * scale); export *[ram]:8 tmp; }


# addc
:addc regS1, regS2, regSD is op2431=0x5b & op0710=0x0 & regS1 & regS2 & regSD unimpl


# addi
:addi regS1, regS2, regSD is op2431=0x59 & op0710=0x1 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS1 + regS2;
}


# addie
:addie regS1, regS2, regSD is op2431=0x7a & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addig
:addig regS1, regS2, regSD is op2431=0x79 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addige
:addige regS1, regS2, regSD is op2431=0x7b & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addil
:addil regS1, regS2, regSD is op2431=0x7c & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addile
:addile regS1, regS2, regSD is op2431=0x7e & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addine
:addine regS1, regS2, regSD is op2431=0x7d & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addino
:addino regS1, regS2, regSD is op2431=0x78 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addio
:addio regS1, regS2, regSD is op2431=0x7f & op0710=0x1 & regS1 & regS2 & regSD unimpl


# addo
:addo regS1, regS2, regSD is op2431=0x59 & op0710=0x0 & regS1 & regS2 & regSD
{
	regSD = regS1 + regS2;
}


# addoe
:addoe regS1, regS2, regSD is op2431=0x7a & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	regSD = regS1 + regS2;
}


# addog
:addog regS1, regS2, regSD is op2431=0x79 & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	regSD = regS1 + regS2;
}


# addoge
:addoge regS1, regS2, regSD is op2431=0x7b & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	regSD = regS1 + regS2;
}


# addol
:addol regS1, regS2, regSD is op2431=0x7c & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	regSD = regS1 + regS2;
}


# addole
:addole regS1, regS2, regSD is op2431=0x7e & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	regSD = regS1 + regS2;
}


# addone
:addone regS1, regS2, regSD is op2431=0x7d & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	regSD = regS1 + regS2;
}


# addono
:addono regS1, regS2, regSD is op2431=0x78 & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (acCC) goto inst_next;
	regSD = regS1 + regS2;
}


# addoo
:addoo regS1, regS2, regSD is op2431=0x7f & op0710=0x0 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!acCC) goto inst_next;
	regSD = regS1 + regS2;
}


# addr
:addr regS1, regS2, regSD is op2431=0x78 & op0710=0xf & regS1 & regS2 & regSD unimpl


# addrl  8,8,8
:addrl regS1, regS2, regSD is op2431=0x79 & op0710=0xf & regS1 & regS2 & regSD unimpl


# alterbit
:alterbit regS1, regS2, regSD is op2431=0x58 & op0710=0xf & regS1 & regS2 & regSD unimpl


# and
:and regS1, regS2, regSD is op2431=0x58 & op0710=0x1 & regS1 & regS2 & regSD
{
	regSD = regS1 & regS2;
}


# andnot
:andnot regS1, regS2, regSD is op2431=0x58 & op0710=0x2 & regS1 & regS2 & regSD
{
	regSD = regS2 & ~regS1;
}


# atadd
:atadd regS1, regS2, regSD is op2431=0x61 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# atanr
:atanr regS1, regS2, regSD is op2431=0x68 & op0710=0x0 & regS1 & regS2 & regSD unimpl


# atanrl  8,8,8
:atanrl regS1, regS2, regSD is op2431=0x69 & op0710=0x0 & regS1 & regS2 & regSD unimpl


# atmod
:atmod regS1, regS2, regSD is op2431=0x61 & op0710=0x0 & regS1 & regS2 & regSD unimpl


# b
:b sdisp0223 is op2431=0x8 & op0000=0x0 & sdisp0223
{
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bal
:bal sdisp0223 is op2431=0xb & op0000=0x0 & sdisp0223
{
	g14 = inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];	
}


# balx
:balx efa1, reg1923 is ( op2431=0x85 & reg1923 ) ... & efa1
{
	local temp:4 = zext(efa1) << 2;
	reg1923 = inst_next;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bbc
:bbc cobrS1, cobrS2, sdisp0212 is op2431=0x30 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	if (((1<<cobrS1) & cobrS2) == 0) goto inst_next;
	ac[1,1] = 1;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];		
}


# bbs
:bbs cobrS1, cobrS2, sdisp0212 is op2431=0x37 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	if (((1<<cobrS1) & cobrS2) != 0) goto inst_next;
	ac[1,1] = 1;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];		
}


# be
:be sdisp0223 is op2431=0x12 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bg
:bg sdisp0223 is op2431=0x11 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bge
:bge sdisp0223 is op2431=0x13 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bl
:bl sdisp0223 is op2431=0x14 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# ble
:ble sdisp0223 is op2431=0x16 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# bne
:bne sdisp0223 is op2431=0x15 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}

# bno
:bno sdisp0223 is op2431=0x10 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (acCC) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}

# bo
:bo sdisp0223 is op2431=0x17 & op0000=0x0 & sdisp0223
{
	local acCC:1 = ac:1 & 0x07;
	if (!acCC) goto inst_next;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}

# bswap
:bswap regS1, regSD is m1=0x1 & op2431=0x5a & op0710=0xd & regS1 & regSD unimpl


# bx
:bx efa1 is ( op2431=0x84 ) ... & efa1
{
	local temp:4 = zext(efa1) << 2;
	goto [temp];
}


# call
:call sdisp0223 is op2431=0x9 & op0000=0x0 & sdisp0223
{
	rip = inst_next;
	pfp = fp;
	fp = (sp + ($(SALIGN) * 16 - 1)) & ~($(SALIGN) * 16 - 1);
	sp = fp + 64;
	local temp:4 = sdisp0223 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	pfp = fp;
	call [temp];	
}


# calls
:calls regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x0 & regS1 unimpl


# callx
:callx efa1 is ( op2431=0x86 ) ... & efa1
{
	rip = inst_next;
	pfp = fp;
	fp = (sp + ($(SALIGN) * 16 - 1)) & ~($(SALIGN) * 16 - 1);
	sp = fp + 64;
	local temp:4 = zext(efa1) << 2;
	pfp = fp;
	call [temp];	
}


# chkbit
:chkbit regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0xe & regS1 & regS2 unimpl


# classr
:classr regS1 is m1=0x1 & m2=0x1 & op2431=0x68 & op0710=0xf & regS1 unimpl


# classrl  8
:classrl regS1 is m1=0x1 & m2=0x1 & op2431=0x69 & op0710=0xf & regS1 unimpl


# clrbit
:clrbit regS1, regS2, regSD is op2431=0x58 & op0710=0xc & regS1 & regS2 & regSD
{
	regSD = regS2 & ~(1 << regS1);
}


# cmpdeci
:cmpdeci regS1, regS2, regSD is op2431=0x5a & op0710=0x7 & regS1 & regS2 & regSD
{
	ac[0,3] = 0;
	ac[2,1] = regS1 s< regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 s> regS2;	
	regSD = regS2 - 1;
}


# cmpdeco
:cmpdeco regS1, regS2, regSD is op2431=0x5a & op0710=0x6 & regS1 & regS2 & regSD
{
	ac[0,3] = 0;
	ac[2,1] = regS1 < regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 > regS2;	
	regSD = regS2 - 1;	
}


# cmpi
:cmpi regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0x1 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1 s< regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 s> regS2;	
}


# cmpib
:cmpib regS1, regS2 is m2=0x1 & op2431=0x59 & op0710=0x5 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1:1 s< regS2:1;
	ac[1,1] = regS1:1 == regS2:1;
	ac[0,1] = regS1:1 s> regS2:1;	
}


# cmpibe
:cmpibe cobrS1, cobrS2, sdisp0212 is op2431=0x3a & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibg
:cmpibg cobrS1, cobrS2, sdisp0212 is op2431=0x39 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}



# cmpibge
:cmpibge cobrS1, cobrS2, sdisp0212 is op2431=0x3b & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibl
:cmpibl cobrS1, cobrS2, sdisp0212 is op2431=0x3c & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpible
:cmpible cobrS1, cobrS2, sdisp0212 is op2431=0x3e & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibne
:cmpibne cobrS1, cobrS2, sdisp0212 is op2431=0x3d & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibno
:cmpibno cobrS1, cobrS2, sdisp0212 is op2431=0x38 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (acCC) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpibo
:cmpibo cobrS1, cobrS2, sdisp0212 is op2431=0x3f & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 s< cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 s> cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!acCC) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpinci
:cmpinci regS1, regS2, regSD is op2431=0x5a & op0710=0x5 & regS1 & regS2 & regSD
{
	ac[0,3] = 0;
	ac[2,1] = regS1 s< regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 s> regS2;	
	regSD = regS2 + 1;
}


# cmpinco
:cmpinco regS1, regS2, regSD is op2431=0x5a & op0710=0x4 & regS1 & regS2 & regSD
{
	ac[0,3] = 0;
	ac[2,1] = regS1 < regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 > regS2;	
	regSD = regS2 - 1;
}


# cmpis
:cmpis regS1, regS2 is m2=0x1 & op2431=0x59 & op0710=0x7 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1:2 s< regS2:2;
	ac[1,1] = regS1:2 == regS2:2;
	ac[0,1] = regS1:2 s> regS2:2;
}


# cmpo
:cmpo regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0x0 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1 < regS2;
	ac[1,1] = regS1 == regS2;
	ac[0,1] = regS1 > regS2;
}


# cmpob
:cmpob regS1, regS2 is m2=0x1 & op2431=0x59 & op0710=0x4 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1:1 < regS2:1;
	ac[1,1] = regS1:1 == regS2:1;
	ac[0,1] = regS1:1 > regS2:1;
}


# cmpobe
:cmpobe cobrS1, cobrS2, sdisp0212 is op2431=0x32 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpobg
:cmpobg cobrS1, cobrS2, sdisp0212 is op2431=0x31 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpobge
:cmpobge cobrS1, cobrS2, sdisp0212 is op2431=0x33 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}

# cmpobl
:cmpobl cobrS1, cobrS2, sdisp0212 is op2431=0x34 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpoble
:cmpoble cobrS1, cobrS2, sdisp0212 is op2431=0x36 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpobne
:cmpobne cobrS1, cobrS2, sdisp0212 is op2431=0x35 & cobrS1 & cobrS2 & sdisp0212
{
	ac[0,3] = 0;
	ac[2,1] = cobrS1 < cobrS2;
	ac[1,1] = cobrS1 == cobrS2;
	ac[0,1] = cobrS1 > cobrS2;
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	local temp:4 = sdisp0212 << 2;
	temp = (inst_start + temp) & 0xfffffffc;
	goto [temp];
}


# cmpor
:cmpor regS1, regS2 is m2=0x1 & op2431=0x68 & op0710=0x4 & regS1 & regS2 unimpl


# cmporl  8,8
:cmporl regS1, regS2 is m2=0x1 & op2431=0x69 & op0710=0x4 & regS1 & regS2 unimpl


# cmpos
:cmpos regS1, regS2 is m2=0x1 & op2431=0x59 & op0710=0x6 & regS1 & regS2
{
	ac[0,3] = 0;
	ac[2,1] = regS1:2 < regS2:2;
	ac[1,1] = regS1:2 == regS2:2;
	ac[0,1] = regS1:2 > regS2:2;
}


# cmpr
:cmpr regS1, regS2 is m2=0x1 & op2431=0x68 & op0710=0x5 & regS1 & regS2 unimpl


# cmprl  8,8
:cmprl regS1, regS2 is m2=0x1 & op2431=0x69 & op0710=0x5 & regS1 & regS2 unimpl


# cmpstr
:cmpstr regS1, regS2, regSD is op2431=0x60 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# concmpi
:concmpi regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0x3 & regS1 & regS2
{
	if ((ac & 4) == 0) goto inst_next;
	ac[0,3] = 0;
	ac[1,1] = regS1 s<= regS2;
	ac[0,1] = regS1 s> regS2;
}


# concmpo
:concmpo regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0x2 & regS1 & regS2
{
	if ((ac & 4) == 0) goto inst_next;
	ac[0,3] = 0;
	ac[1,1] = regS1 <= regS2;
	ac[0,1] = regS1 > regS2;
}


# condrec
:condrec regS1, regSD is m1=0x1 & op2431=0x64 & op0710=0x6 & regS1 & regSD unimpl


# condwait
:condwait regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x8 & regS1 unimpl


# cosr
:cosr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xd & regS1 & regSD unimpl


# cosrl  8,8
:cosrl regS1, regSD is m1=0x1 & op2431=0x69 & op0710=0xd & regS1 & regSD unimpl


# cpyrsre
#TODO  tq
# :cpyrsre regS1tq, regS2tq, regSDtq is op2431=0x6e & op0710=0x3 & regS1tq & regS2tq & regSDtq unimpl


# cpysre
#TODO  tq
# :cpysre regS1tq, regS2tq, regSDtq is op2431=0x6e & op0710=0x2 & regS1tq & regS2tq & regSDtq unimpl


# cvtadr  4,8
:cvtadr regS1, regSD is m1=0x1 & op2431=0x67 & op0710=0x2 & regS1 & regSD unimpl


# cvtilr
:cvtilr regS1, regSD is m1=0x1 & op2431=0x67 & op0710=0x5 & regS1 & regSD unimpl


# cvtir
:cvtir regS1, regSD is m1=0x1 & op2431=0x67 & op0710=0x4 & regS1 & regSD unimpl


# cvtri
:cvtri regS1, regSD is m1=0x1 & op2431=0x6c & op0710=0x0 & regS1 & regSD unimpl


# cvtril  4,8
:cvtril regS1, regSD is m1=0x1 & op2431=0x6c & op0710=0x1 & regS1 & regSD unimpl


# cvtzri
:cvtzri regS1, regSD is m1=0x1 & op2431=0x6c & op0710=0x2 & regS1 & regSD unimpl


# cvtzril  4,8
:cvtzril regS1, regSD is m1=0x1 & op2431=0x6c & op0710=0x3 & regS1 & regSD unimpl


# daddc
:daddc regS1, regS2, regSD is op2431=0x64 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# dcctl
:dcctl regS1, regS2, regSD is op2431=0x65 & op0710=0xc & regS1 & regS2 & regSD unimpl


# dcinva
:dcinva efa1 is ( op2431=0xac ) ... & efa1 unimpl


# divi
:divi regS1, regS2, regSD is op2431=0x74 & op0710=0xb & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 s/ regS1;
}


# divo
:divo regS1, regS2, regSD is op2431=0x70 & op0710=0xb & regS1 & regS2 & regSD
{
	regSD = regS2 / regS1;
}


# divr
:divr regS1, regS2, regSD is op2431=0x78 & op0710=0xb & regS1 & regS2 & regSD unimpl


# divrl  8,8,8
:divrl regS1, regS2, regSD is op2431=0x79 & op0710=0xb & regS1 & regS2 & regSD unimpl


# dmovt
:dmovt regS1, regSD is m1=0x1 & op2431=0x64 & op0710=0x4 & regS1 & regSD unimpl


# dsubc
:dsubc regS1, regS2, regSD is op2431=0x64 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# ediv  4,8,4
:ediv regS1, regS2, regSD is op2431=0x67 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# emul  4,4,8
:emul regS1, regS2, regSD is op2431=0x67 & op0710=0x0 & regS1 & regS2 & regSD
{
	local tmp:8 = zext(regS1) * zext(regS2);
	local dst:4 = &regSD;
	*[register]:8 dst = tmp;
}


# eshro
:eshro regS1, regS2, regSD is op2431=0x5d & op0710=0x8 & regS1 & regS2 & regSD unimpl


# expr
:expr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0x9 & regS1 & regSD unimpl


# exprl  8,8
:exprl regS1, regSD is m1=0x1 & op2431=0x69 & op0710=0x9 & regS1 & regSD unimpl


# extract
:extract regS1, regS2, regSD is op2431=0x65 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# faulte
:faulte  is op2431=0x1a & op0000=0x0 unimpl


# faultg
:faultg  is op2431=0x19 & op0000=0x0 unimpl


# faultge
:faultge  is op2431=0x1b & op0000=0x0 unimpl


# faultl
:faultl  is op2431=0x1c & op0000=0x0 unimpl


# faultle
:faultle  is op2431=0x1e & op0000=0x0 unimpl


# faultne
:faultne  is op2431=0x1d & op0000=0x0 unimpl


# faultno
:faultno  is op2431=0x18 & op0000=0x0 unimpl


# faulto
:faulto  is op2431=0x1f & op0000=0x0 unimpl


# fill
:fill regS1, regS2, regSD is op2431=0x61 & op0710=0x7 & regS1 & regS2 & regSD unimpl


# flushreg
:flushreg  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xd unimpl


# fmark
:fmark  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xc unimpl


# halt
:halt regS1 is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x65 & op0710=0xd & regS1 unimpl


# icctl
:icctl regS1, regS2, regSD is op2431=0x65 & op0710=0xb & regS1 & regS2 & regSD unimpl


# inspacc
:inspacc regS1, regSD is m1=0x1 & op2431=0x61 & op0710=0x3 & regS1 & regSD unimpl


# intctl
:intctl regS1, regSD is m1=0x1 & op2431=0x65 & op0710=0x8 & regS1 & regSD unimpl


# intdis
:intdis  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x5b & op0710=0x4 unimpl


# inten
:inten  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x5b & op0710=0x5 unimpl


# ld
:ld efa4, reg1923 is ( op2431=0x90 & reg1923 ) ... & efa4
{
	reg1923 = efa4;
}


# lda
:lda efa1, reg1923 is ( op2431=0x8c & reg1923 ) ... & efa1
{
	reg1923 = zext(efa1);
}


# ldib
:ldib efa1, reg1923 is ( op2431=0xc0 & reg1923 ) ... & efa1
{
	reg1923 = sext(efa1);
}


# ldis
:ldis efa2, reg1923 is ( op2431=0xc8 & reg1923 ) ... & efa2
{
	reg1923 = sext(efa2);
}


# ldl
:ldl efa8, reg1923 is ( op2431=0x98 & reg1923 ) ... & efa8
{
	local dst:4 = &reg1923;
	*[register]:8 dst = efa8;
}


# ldob
:ldob efa1, reg1923 is ( op2431=0x80 & reg1923 ) ... & efa1
{
	reg1923 = zext(efa1);
}


# ldos
:ldos efa2, reg1923 is ( op2431=0x88 & reg1923 ) ... & efa2
{
	reg1923 = zext(efa2);
}


# ldphy
:ldphy regS1, regSD is m1=0x1 & op2431=0x61 & op0710=0x4 & regS1 & regSD unimpl


# ldq
:ldq efa16, reg1923 is ( op2431=0xb0 & reg1923 ) ... & efa16
{
	local dst:4 = &reg1923;
	*[register]:16 dst = efa16;
}


# ldt
:ldt efa12, reg1923 is ( op2431=0xa0 & reg1923 ) ... & efa12
{
	local dst:4 = &reg1923;
	*[register]:12 dst = efa12;
}


# ldtime  8
:ldtime regSD is m0=0x1 & m1=0x1 & op2431=0x67 & op0710=0x3 & regSD unimpl


# logbnr
:logbnr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xa & regS1 & regSD unimpl


# logbnrl  8,8
:logbnrl regS1, regSD is m1=0x1 & op2431=0x69 & op0710=0xa & regS1 & regSD unimpl


# logepr
:logepr regS1, regS2, regSD is op2431=0x68 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# logeprl  8,8,8
:logeprl regS1, regS2, regSD is op2431=0x69 & op0710=0x1 & regS1 & regS2 & regSD unimpl


# logr
:logr regS1, regS2, regSD is op2431=0x68 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# logrl  8,8,8
:logrl regS1, regS2, regSD is op2431=0x69 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# mark
:mark  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xb unimpl


# modac
:modac regS1, regS2, regSD is op2431=0x64 & op0710=0x5 & regS1 & regS2 & regSD unimpl


# modi
:modi regS1, regS2, regSD is op2431=0x74 & op0710=0x9 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 s/ regS1;
}


# modify
:modify regS1, regS2, regSD is op2431=0x65 & op0710=0x0 & regS1 & regS2 & regSD
{
	regSD = (regS2 & regS1) | (regSD & ~regS1);
}


# modpc
:modpc regS1, regS2, regSD is op2431=0x65 & op0710=0x5 & regS1 & regS2 & regSD unimpl


# modtc
:modtc regS1, regS2, regSD is op2431=0x65 & op0710=0x4 & regS1 & regS2 & regSD unimpl


# mov
:mov regS1, regSD is m1=0x1 & op2431=0x5c & op0710=0xc & regS1 & regSD
{
	regSD = regS1;
}


# movl
:movl regS1, regSD is m1=0x1 & op2431=0x5d & op0710=0xc & regS1 & regSD
{
	local src:4 = &regS1;
	local dst:4 = &regSD;
	*[register]:8 dst = *[register]:8 src;
}


# movq
:movq regS1, regSD is m1=0x1 & op2431=0x5f & op0710=0xc & regS1 & regSD
{
	local src:4 = &regS1;
	local dst:4 = &regSD;
	*[register]:16 dst = *[register]:16 src;
}


# movqstr
:movqstr regS1, regS2, regSD is op2431=0x60 & op0710=0x4 & regS1 & regS2 & regSD unimpl


# movr
:movr regS1, regSD is m1=0x1 & op2431=0x6c & op0710=0x9 & regS1 & regSD unimpl


# movre
#TODO  tq
# :movre regS1tq, regSDtq is m1=0x1 & op2431=0x6e & op0710=0x1 & regS1tq & regSDtq unimpl


# movrl  8,8
:movrl regS1, regSD is m1=0x1 & op2431=0x6d & op0710=0x9 & regS1 & regSD unimpl


# movstr
:movstr regS1, regS2, regSD is op2431=0x60 & op0710=0x5 & regS1 & regS2 & regSD unimpl


# movt
:movt regS1, regSD is m1=0x1 & op2431=0x5e & op0710=0xc & regS1 & regSD
{
	local src:4 = &regS1;
	local dst:4 = &regSD;
	*[register]:12 dst = *[register]:12 src;
}


# muli
:muli regS1, regS2, regSD is op2431=0x74 & op0710=0x1 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS1 * regS2;
}


# mulo
:mulo regS1, regS2, regSD is op2431=0x70 & op0710=0x1 & regS1 & regS2 & regSD
{
	regSD = regS1 * regS2;
}


# mulr
:mulr regS1, regS2, regSD is op2431=0x78 & op0710=0xc & regS1 & regS2 & regSD unimpl


# mulrl  8,8,8
:mulrl regS1, regS2, regSD is op2431=0x79 & op0710=0xc & regS1 & regS2 & regSD unimpl


# nand
:nand regS1, regS2, regSD is op2431=0x58 & op0710=0xe & regS1 & regS2 & regSD
{
	regSD = ~regS1 | ~regS2;
}


# nor
:nor regS1, regS2, regSD is op2431=0x58 & op0710=0x8 & regS1 & regS2 & regSD
{
	regSD = ~regS1 & ~regS2;
}


# not
:not regS1, regSD is m1=0x1 & op2431=0x58 & op0710=0xa & regS1 & regSD
{
	regSD = ~regS1;
}


# notand
:notand regS1, regS2, regSD is op2431=0x58 & op0710=0x4 & regS1 & regS2 & regSD
{
	regSD = ~(regS1 & regS2);
}


# notbit
:notbit regS1, regS2, regSD is op2431=0x58 & op0710=0x0 & regS1 & regS2 & regSD
{
	regSD = regS2 ^ (1 << regS1);
}


# notor
:notor regS1, regS2, regSD is op2431=0x58 & op0710=0xd & regS1 & regS2 & regSD
{
	regSD = ~regS2 | regS1;
}


# or
:or regS1, regS2, regSD is op2431=0x58 & op0710=0x7 & regS1 & regS2 & regSD
{
	regSD = regS2 | regS1;
}


# ornot
:ornot regS1, regS2, regSD is op2431=0x58 & op0710=0xb & regS1 & regS2 & regSD
{
	regSD = regS2 | ~regS1;
}


# receive
:receive regS1, regSD is m1=0x1 & op2431=0x65 & op0710=0x6 & regS1 & regSD unimpl


# remi
:remi regS1, regS2, regSD is op2431=0x74 & op0710=0x8 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 s% regS2;
}


# remo
:remo regS1, regS2, regSD is op2431=0x70 & op0710=0x8 & regS1 & regS2 & regSD
{
	regSD = regS2 % regS1;
}


# remr
:remr regS1, regS2, regSD is op2431=0x68 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# remrl  8,8,8
:remrl regS1, regS2, regSD is op2431=0x69 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# resumprcs
:resumprcs regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x4 & regS1 unimpl


# ret
:ret  is op2431=0xa & op0000=0x0
{
	fp = pfp;
	return [rip];
}


# rotate
:rotate regS1, regS2, regSD is op2431=0x59 & op0710=0xd & regS1 & regS2 & regSD unimpl


# roundr
:roundr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xb & regS1 & regSD unimpl


# roundrl  8,8
:roundrl regS1, regSD is m1=0x1 & op2431=0x69 & op0710=0xb & regS1 & regSD unimpl


# saveprcs
:saveprcs  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x6 unimpl


# scaler
:scaler regS1, regS2, regSD is op2431=0x67 & op0710=0x7 & regS1 & regS2 & regSD unimpl


# scalerl  4,8,8
:scalerl regS1, regS2, regSD is op2431=0x67 & op0710=0x6 & regS1 & regS2 & regSD unimpl


# scanbit
:scanbit regS1, regSD is m1=0x1 & op2431=0x64 & op0710=0x1 & regS1 & regSD unimpl


# scanbyte
:scanbyte regS1, regS2 is m2=0x1 & op2431=0x5a & op0710=0xc & regS1 & regS2
{
	ac[0,3] = 0;
	local code = (regS1[24,8] == regS2[24,8]) ||
	      	     (regS1[16,8] == regS2[16,8]) ||
		     (regS1[8,8] == regS2[8,8]) ||
		     (regS1[0,8] == regS2[0,8]);
	ac[1,1] = code; 
}


# schedprcs
:schedprcs regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x5 & regS1 unimpl


# sdma
:sdma regS1, regS2, regSD is op2431=0x63 & op0710=0x0 & regS1 & regS2 & regSD unimpl


# sele
:sele regS1, regS2, regSD is op2431=0x7a & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 2) == 0) goto inst_next;
	regSD = regS2;
}


# selg
:selg regS1, regS2, regSD is op2431=0x79 & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 1) == 0) goto inst_next;
	regSD = regS2;
}


# selge
:selge regS1, regS2, regSD is op2431=0x7b & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 3) == 0) goto inst_next;
	regSD = regS2;
}


# sell
:sell regS1, regS2, regSD is op2431=0x7c & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 4) == 0) goto inst_next;
	regSD = regS2;
}


# selle
:selle regS1, regS2, regSD is op2431=0x7e & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 6) == 0) goto inst_next;
	regSD = regS2;
}


# selne
:selne regS1, regS2, regSD is op2431=0x7d & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if ((acCC & 5) == 0) goto inst_next;
	regSD = regS2;
}


# selno
:selno regS1, regS2, regSD is op2431=0x78 & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if (acCC != 0) goto inst_next;
	regSD = regS2;
}


# selo
:selo regS1, regS2, regSD is op2431=0x7f & op0710=0x4 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	regSD = regS1;
	if (acCC == 0) goto inst_next;
	regSD = regS2;
}


# send
:send regS1, regS2, regSD is op2431=0x66 & op0710=0x2 & regS1 & regS2 & regSD unimpl


# sendserv
:sendserv regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x3 & regS1 unimpl


# setbit
:setbit regS1, regS2, regSD is op2431=0x58 & op0710=0x3 & regS1 & regS2 & regSD
{
	regSD = regS2 | (1 << regS1);
}


# shli
:shli regS1, regS2, regSD is op2431=0x59 & op0710=0xe & regS1 & regS2 & regSD
{
	#TODO  overflow
	regSD = regS2 << regS1;
}


# shlo
:shlo regS1, regS2, regSD is op2431=0x59 & op0710=0xc & regS1 & regS2 & regSD
{
	regSD = regS2 << regS1;
}


# shrdi
:shrdi regS1, regS2, regSD is op2431=0x59 & op0710=0xa & regS1 & regS2 & regSD
{
	#TODO  are there flags here?
	#TODO  is this correct?
	# (x + ((x >> 31) & ((1 << n) + ~0))) >> n
	regSD = (regS2 + ((regS2 s>> 31) & ((1 << regS1) + ~0))) s>> regS1;
}


# shri
:shri regS1, regS2, regSD is op2431=0x59 & op0710=0xb & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 s>> regS1;
}


# shro
:shro regS1, regS2, regSD is op2431=0x59 & op0710=0x8 & regS1 & regS2 & regSD
{
	regSD = regS2 >> regS1;
}


# signal
:signal regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xa & regS1 unimpl


# sinr
:sinr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xc & regS1 & regSD unimpl


# sinrl  8,8
:sinrl regS1, regSD is m1=0x1 & op2431=0x69 & op0710=0xc & regS1 & regSD unimpl


# spanbit
:spanbit regS1, regSD is m1=0x1 & op2431=0x64 & op0710=0x0 & regS1 & regSD unimpl


# sqrtr
:sqrtr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0x8 & regS1 & regSD unimpl


# sqrtrl  8,8
:sqrtrl regS1, regSD is m1=0x1 & op2431=0x69 & op0710=0x8 & regS1 & regSD unimpl


# st
:st reg1923, efa4 is ( op2431=0x92 & reg1923 ) ... & efa4
{
	efa4 = reg1923;
}


# stib
:stib reg1923, efa1 is ( op2431=0xc2 & reg1923 ) ... & efa1
{
	efa1 = reg1923:1;
}


# stis
:stis reg1923, efa2 is ( op2431=0xca & reg1923 ) ... & efa2
{
	efa2 = reg1923:2;
}


# stl
:stl reg1923, efa8 is ( op2431=0x9a & reg1923 ) ... & efa8
{
	local src:4 = &reg1923;
	efa8 = *[register]:8 src;
}


# stob
:stob reg1923, efa1 is ( op2431=0x82 & reg1923 ) ... & efa1
{
	efa1 = reg1923:1;
}


# stos
:stos reg1923, efa2 is ( op2431=0x8a & reg1923 ) ... & efa2
{
	efa2 = reg1923:2;
}


# stq
:stq reg1923, efa16 is ( op2431=0xb2 & reg1923 ) ... & efa16
{
	local src:4 = &reg1923;
	efa16 = *[register]:16 src;
}


# stt
:stt reg1923, efa12 is ( op2431=0xa2 & reg1923 ) ... & efa12
{
	local src:4 = &reg1923;
	efa12 = *[register]:12 src;
}


# subc
:subc regS1, regS2, regSD is op2431=0x5b & op0710=0x2 & regS1 & regS2 & regSD
{
	local tmp:4 = zext(ac[1,1]);
	ac[2,1] = 0;
	ac[1,1] = ((regS1 - 1) + tmp) > regS2;
	ac[0,1] = ((regS1 - 1) + tmp) s> regS2;
	regSD = regS2 + (regS1 - 1) + tmp;
}


# subi
:subi regS1, regS2, regSD is op2431=0x59 & op0710=0x3 & regS1 & regS2 & regSD
{
	#TODO  flags
	regSD = regS2 - regS1;
}


# subie
:subie regS1, regS2, regSD is op2431=0x7a & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subig
:subig regS1, regS2, regSD is op2431=0x79 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subige
:subige regS1, regS2, regSD is op2431=0x7b & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subil
:subil regS1, regS2, regSD is op2431=0x7c & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subile
:subile regS1, regS2, regSD is op2431=0x7e & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subine
:subine regS1, regS2, regSD is op2431=0x7d & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subino
:subino regS1, regS2, regSD is op2431=0x78 & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subio
:subio regS1, regS2, regSD is op2431=0x7f & op0710=0x3 & regS1 & regS2 & regSD unimpl


# subo
:subo regS1, regS2, regSD is op2431=0x59 & op0710=0x2 & regS1 & regS2 & regSD
{
	regSD = regS2 - regS1;
}


# suboe
:suboe regS1, regS2, regSD is op2431=0x7a & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	regSD = regS2 - regS1;
}


# subog
:subog regS1, regS2, regSD is op2431=0x79 & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 1)) goto inst_next;
	regSD = regS2 - regS1;
}


# suboge
:suboge regS1, regS2, regSD is op2431=0x7b & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 3)) goto inst_next;
	regSD = regS2 - regS1;
}


# subol
:subol regS1, regS2, regSD is op2431=0x7c & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 4)) goto inst_next;
	regSD = regS2 - regS1;
}


# subole
:subole regS1, regS2, regSD is op2431=0x7e & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 6)) goto inst_next;
	regSD = regS2 - regS1;
}


# subone
:subone regS1, regS2, regSD is op2431=0x7d & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 5)) goto inst_next;
	regSD = regS2 - regS1;
}


# subono
:subono regS1, regS2, regSD is op2431=0x78 & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (acCC) goto inst_next;
	regSD = regS2 - regS1;
}


# suboo
:suboo regS1, regS2, regSD is op2431=0x7f & op0710=0x2 & regS1 & regS2 & regSD
{
	local acCC:1 = ac:1 & 0x07;
	if (!(acCC & 2)) goto inst_next;
	regSD = regS2 - regS1;
}


# subr
:subr regS1, regS2, regSD is op2431=0x78 & op0710=0xd & regS1 & regS2 & regSD unimpl


# subrl  8,8,8
:subrl regS1, regS2, regSD is op2431=0x79 & op0710=0xd & regS1 & regS2 & regSD unimpl


# syncf
:syncf  is m0=0x1 & m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0xf unimpl


# synld
:synld regS1, regSD is m1=0x1 & op2431=0x61 & op0710=0x5 & regS1 & regSD
{
	#TODO  this might need work
	regSD = *[ram]:4 regS1;
}


# synmov
:synmov regS1, regS2 is m2=0x1 & op2431=0x60 & op0710=0x0 & regS1 & regS2
{
	#TODO  this might need work
	*[ram]:4 regS1 = *[ram]:4 regS2;
}


# synmovl
:synmovl regS1, regS2 is m2=0x1 & op2431=0x60 & op0710=0x1 & regS1 & regS2
{
	#TODO  this might need work
	*[ram]:8 regS1 = *[ram]:8 regS2;
}


# synmovq
:synmovq regS1, regS2 is m2=0x1 & op2431=0x60 & op0710=0x2 & regS1 & regS2
{
	#TODO  this might need work
	*[ram]:16 regS1 = *[ram]:16 regS2;
}


# syscall
:syscall  is op2431=0x1 & op0000=0x0 unimpl


# sysctl
:sysctl regS1, regS2, regSD is op2431=0x65 & op0710=0x9 & regS1 & regS2 & regSD unimpl


# tanr
:tanr regS1, regSD is m1=0x1 & op2431=0x68 & op0710=0xe & regS1 & regSD unimpl


# tanrl  8,8
:tanrl regS1, regSD is m1=0x1 & op2431=0x69 & op0710=0xe & regS1 & regSD unimpl


# teste
:teste cobrSD is op2431=0x22 & cobrSD
{
	cobrSD = zext((ac & 2) != 0);
}


# testg
:testg cobrSD is op2431=0x21 & cobrSD
{
	cobrSD = zext((ac & 1) != 0);
}


# testge
:testge cobrSD is op2431=0x23 & cobrSD
{
	cobrSD = zext((ac & 3) != 0);
}


# testl
:testl cobrSD is op2431=0x24 & cobrSD
{
	cobrSD = zext((ac & 4) != 0);
}


# testle
:testle cobrSD is op2431=0x26 & cobrSD
{
	cobrSD = zext((ac & 6) != 0);
}


# testne
:testne cobrSD is op2431=0x25 & cobrSD
{
	cobrSD = zext((ac & 5) != 0);
}


# testno
:testno cobrSD is op2431=0x20 & cobrSD
{
	cobrSD = zext((ac & 7) == 0);
}


# testo
:testo cobrSD is op2431=0x27 & cobrSD
{
	cobrSD = zext((ac & 7) != 0);
}


# udma
:udma  is op2431=0x63 & op0710=0x1 unimpl


# wait
:wait regS1 is m1=0x1 & m2=0x1 & op2431=0x66 & op0710=0x9 & regS1 unimpl


# xnor
:xnor regS1, regS2, regSD is op2431=0x58 & op0710=0x9 & regS1 & regS2 & regSD
{
	regSD = ~(regS1 | regS2) | (regS1 & regS2);
}


# xor
:xor regS1, regS2, regSD is op2431=0x58 & op0710=0x6 & regS1 & regS2 & regSD
{
	regSD = regS1 ^ regS2;
}


